<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SILLY Grammar Parser</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #00d9ff;
        }
        
        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
        }
        
        .input-section {
            background: #16213e;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #00d9ff;
            font-weight: 500;
        }
        
        select, input, button {
            padding: 12px 16px;
            border-radius: 6px;
            border: 1px solid #333;
            font-size: 16px;
        }
        
        select {
            background: #0f0f23;
            color: #eee;
            min-width: 180px;
        }
        
        input {
            flex: 1;
            min-width: 300px;
            background: #0f0f23;
            color: #eee;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        input:focus {
            outline: none;
            border-color: #00d9ff;
        }
        
        button {
            background: #00d9ff;
            color: #1a1a2e;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #00b8d9;
        }
        
        .examples {
            margin-top: 15px;
        }
        
        .examples-title {
            color: #888;
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .example-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .example-btn {
            background: #2a2a4a;
            color: #aaa;
            padding: 6px 12px;
            font-size: 13px;
            font-family: 'Consolas', monospace;
        }
        
        .example-btn:hover {
            background: #3a3a5a;
            color: #eee;
        }
        
        .result-section {
            background: #16213e;
            padding: 20px;
            border-radius: 10px;
            min-height: 300px;
        }
        
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .result-title {
            color: #00d9ff;
            font-weight: 500;
        }
        
        .status {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
        }
        
        .status.valid {
            background: #0a3d2a;
            color: #4ade80;
        }
        
        .status.invalid {
            background: #3d0a0a;
            color: #f87171;
        }
        
        .error-message {
            background: #2d1b1b;
            border-left: 4px solid #f87171;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 0 6px 6px 0;
        }
        
        .tree-container {
            overflow-x: auto;
            padding: 20px 0;
        }
        
        .tree {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .tree ul {
            padding-top: 20px;
            position: relative;
            transition: all 0.3s;
            display: flex;
            justify-content: center;
        }
        
        .tree li {
            list-style: none;
            text-align: center;
            position: relative;
            padding: 20px 8px 0 8px;
        }
        
        .tree li::before, .tree li::after {
            content: '';
            position: absolute;
            top: 0;
            right: 50%;
            border-top: 2px solid #444;
            width: 50%;
            height: 20px;
        }
        
        .tree li::after {
            right: auto;
            left: 50%;
            border-left: 2px solid #444;
        }
        
        .tree li:only-child::after, .tree li:only-child::before {
            display: none;
        }
        
        .tree li:only-child {
            padding-top: 0;
        }
        
        .tree li:first-child::before, .tree li:last-child::after {
            border: 0 none;
        }
        
        .tree li:last-child::before {
            border-right: 2px solid #444;
            border-radius: 0 5px 0 0;
        }
        
        .tree li:first-child::after {
            border-radius: 5px 0 0 0;
        }
        
        .tree ul ul::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            border-left: 2px solid #444;
            width: 0;
            height: 20px;
        }
        
        .node {
            display: inline-block;
            padding: 8px 14px;
            border-radius: 6px;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            position: relative;
        }
        
        .node.nonterminal {
            background: #2563eb;
            color: white;
            border: 2px solid #3b82f6;
        }
        
        .node.terminal {
            background: #059669;
            color: white;
            border: 2px solid #10b981;
        }
        
        .node.keyword {
            background: #7c3aed;
            color: white;
            border: 2px solid #8b5cf6;
        }
        
        .node.operator {
            background: #dc2626;
            color: white;
            border: 2px solid #ef4444;
        }
        
        .text-tree {
            background: #0f0f23;
            padding: 20px;
            border-radius: 6px;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre;
            overflow-x: auto;
        }
        
        .toggle-view {
            background: #2a2a4a;
            font-size: 13px;
        }
        
        .grammar-ref {
            margin-top: 20px;
            background: #16213e;
            padding: 20px;
            border-radius: 10px;
        }
        
        .grammar-ref h3 {
            color: #00d9ff;
            margin-bottom: 15px;
        }
        
        .grammar-ref pre {
            background: #0f0f23;
            padding: 15px;
            border-radius: 6px;
            font-size: 13px;
            overflow-x: auto;
            line-height: 1.5;
        }
        
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SILLY Grammar Parser</h1>
        <p class="subtitle">CSC 533: Programming Languages — Parse Tree Generator</p>
        
        <div class="input-section">
            <div class="input-row">
                <div>
                    <label for="parseType">Parse as:</label>
                    <select id="parseType">
                        <optgroup label="Primitives">
                            <option value="id">Identifier</option>
                            <option value="expr">Expression</option>
                            <option value="list">List</option>
                        </optgroup>
                        <optgroup label="Statements">
                            <option value="statement">Statement (any)</option>
                            <option value="assign">Assignment</option>
                            <option value="var">Var Declaration</option>
                            <option value="print">Print</option>
                            <option value="exit">Exit</option>
                        </optgroup>
                        <optgroup label="Control Flow">
                            <option value="if">If Statement</option>
                            <option value="while">While Loop</option>
                            <option value="repeat">Repeat Loop</option>
                        </optgroup>
                        <optgroup label="Subroutines">
                            <option value="sub">Subroutine Declaration</option>
                            <option value="call">Subroutine Call</option>
                        </optgroup>
                    </select>
                </div>
                <div style="flex: 1;">
                    <label for="inputCode">Input:</label>
                    <input type="text" id="inputCode" placeholder="Enter code to parse..." value="(x + 10)">
                </div>
                <div style="align-self: flex-end;">
                    <button onclick="parse()">Parse</button>
                </div>
            </div>
            
            <div class="examples">
                <div class="examples-title">Quick examples (click to load):</div>
                <div class="example-buttons" id="exampleButtons">
                    
                </div>
            </div>
        </div>
        
        <div class="result-section">
            <div class="result-header">
                <span class="result-title">Parse Tree</span>
                <div>
                    <button class="toggle-view" onclick="toggleView()">Toggle Text/Visual</button>
                    <span class="status" id="status"></span>
                </div>
            </div>
            <div id="errorMessage" class="error-message" style="display: none;"></div>
            <div id="treeOutput" class="tree-container"></div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #2563eb;"></div>
                    <span>Non-terminal</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #059669;"></div>
                    <span>Terminal</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #7c3aed;"></div>
                    <span>Keyword</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #dc2626;"></div>
                    <span>Operator</span>
                </div>
            </div>
        </div>
        
        <div class="grammar-ref">
            <h3>SILLY v.25 Grammar Reference</h3>
            <pre>
&lt;statement&gt;  --&gt; &lt;assign&gt; | &lt;var&gt; | &lt;print&gt; | &lt;if&gt; | &lt;while&gt; |
                 &lt;repeat&gt; | &lt;sub&gt; | &lt;call&gt; | &lt;exit&gt;

&lt;assign&gt;     --&gt; &lt;id&gt; 'gets' &lt;expr&gt;
&lt;var&gt;        --&gt; 'var' &lt;assign&gt;
&lt;print&gt;      --&gt; 'print' &lt;expr&gt;

&lt;if&gt;         --&gt; 'if' &lt;expr&gt; 'then' &lt;body&gt; 
                 { 'elseif' &lt;expr&gt; 'then' &lt;body&gt; } 
                 [ 'else' &lt;body&gt; ] 'endif'

&lt;while&gt;      --&gt; 'while' &lt;expr&gt; 'do' &lt;body&gt; 'endwhile'
&lt;repeat&gt;     --&gt; 'repeat' &lt;expr&gt; 'times' &lt;body&gt; 'endrepeat'

&lt;body&gt;       --&gt; { &lt;statement&gt; }

&lt;sub&gt;        --&gt; 'sub' &lt;id&gt; '(' { &lt;id&gt; } ')' 'does' &lt;body&gt; 'endsub'
&lt;call&gt;       --&gt; 'call' &lt;id&gt; '(' { &lt;expr&gt; } ')'
&lt;exit&gt;       --&gt; 'exit'

&lt;expr&gt;       --&gt; &lt;integer&gt; | &lt;boolean&gt; | &lt;string&gt; | &lt;list&gt; | &lt;id&gt; | 
                 '(' &lt;unary-op&gt; &lt;expr&gt; ')' | '(' &lt;expr&gt; &lt;binary-op&gt; &lt;expr&gt; ')'

&lt;id&gt;         --&gt; &lt;letter&gt; { (&lt;letter&gt; | &lt;digit&gt;) }
&lt;integer&gt;    --&gt; [ '-' ] &lt;digit&gt; { &lt;digit&gt; }
&lt;string&gt;     --&gt; '"' { &lt;nwnq&gt; } '"'
&lt;boolean&gt;    --&gt; 'true' | 'false'  
&lt;list&gt;       --&gt; '['  { &lt;expr&gt; } ']'

&lt;letter&gt;     --&gt; 'a' | 'b' | 'c' | ... | 'z' | 'A' | 'B' | 'C' | ... | 'Z'
&lt;digit&gt;      --&gt; '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' 
&lt;nwnq&gt;       --&gt; any non-whitespace character other than '"' or '\''

&lt;unary-op&gt;   --&gt; '!' | '#' 
&lt;binary-op&gt;  --&gt; '&amp;' | '|' | '+' | '*' | '/' | '%' | '^' | '@' |
                 '='  | '\'  | '&gt;' | '&lt;'</pre>
        </div>
    </div>

    <script>
        const KEYWORDS = ['gets', 'var', 'print', 'if', 'then', 'elseif', 'else', 'endif', 
                          'while', 'do', 'endwhile', 'repeat', 'times', 'endrepeat',
                          'sub', 'does', 'endsub', 'call', 'exit', 'true', 'false'];
        const UNARY_OPS = ['!', '#'];
        const BINARY_OPS = ['&', '|', '+', '*', '/', '%', '^', '@', '=', '\\', '>', '<'];
        const DELIMITERS = ['(', ')', '[', ']', '"'];

        function tokenize(input) {
            const tokens = [];
            let i = 0;
            
            while (i < input.length) {
                if (/\s/.test(input[i])) {
                    i++;
                    continue;
                }
                
                if (input[i] === '"') {
                    let str = '"';
                    i++;
                    while (i < input.length && input[i] !== '"') {
                        if (/\s/.test(input[i]) || input[i] === "'") {
                            throw new Error(`Invalid character in string: '${input[i]}' at position ${i}`);
                        }
                        str += input[i];
                        i++;
                    }
                    if (i >= input.length) {
                        throw new Error('Unterminated string literal');
                    }
                    str += '"';
                    i++;
                    tokens.push({ type: 'STRING', value: str });
                    continue;
                }
                
                if (DELIMITERS.includes(input[i]) || UNARY_OPS.includes(input[i]) || BINARY_OPS.includes(input[i])) {
                    tokens.push({ type: 'SYMBOL', value: input[i] });
                    i++;
                    continue;
                }
                
                if (/\d/.test(input[i]) || (input[i] === '-' && i + 1 < input.length && /\d/.test(input[i + 1]))) {
                    let num = '';
                    if (input[i] === '-') {
                        num = '-';
                        i++;
                    }
                    while (i < input.length && /\d/.test(input[i])) {
                        num += input[i];
                        i++;
                    }
                    tokens.push({ type: 'INTEGER', value: num });
                    continue;
                }
                
                if (/[a-zA-Z]/.test(input[i])) {
                    let id = '';
                    while (i < input.length && /[a-zA-Z0-9]/.test(input[i])) {
                        id += input[i];
                        i++;
                    }
                    if (KEYWORDS.includes(id)) {
                        tokens.push({ type: 'KEYWORD', value: id });
                    } else {
                        tokens.push({ type: 'ID', value: id });
                    }
                    continue;
                }
                
                throw new Error(`Unexpected character: '${input[i]}' at position ${i}`);
            }
            
            return tokens;
        }

        class Parser {
            constructor(tokens) {
                this.tokens = tokens;
                this.pos = 0;
            }
            
            peek() {
                return this.tokens[this.pos] || null;
            }
            
            consume(expectedType, expectedValue) {
                const token = this.peek();
                if (!token) {
                    throw new Error(`Unexpected end of input, expected ${expectedValue || expectedType}`);
                }
                if (expectedType && token.type !== expectedType) {
                    throw new Error(`Expected ${expectedType} but got ${token.type} ('${token.value}')`);
                }
                if (expectedValue && token.value !== expectedValue) {
                    throw new Error(`Expected '${expectedValue}' but got '${token.value}'`);
                }
                this.pos++;
                return token;
            }
            
            isAtEnd() {
                return this.pos >= this.tokens.length;
            }
            
            // <id> --> <letter> { (<letter> | <digit>) }
            parseId() {
                const token = this.consume('ID');
                const node = { type: 'nonterminal', label: '<id>', children: [] };
                
                for (let i = 0; i < token.value.length; i++) {
                    const char = token.value[i];
                    if (/[a-zA-Z]/.test(char)) {
                        node.children.push({
                            type: 'nonterminal',
                            label: '<letter>',
                            children: [{ type: 'terminal', label: char }]
                        });
                    } else {
                        node.children.push({
                            type: 'nonterminal',
                            label: '<digit>',
                            children: [{ type: 'terminal', label: char }]
                        });
                    }
                }
                
                return node;
            }
            
            parseInteger() {
                const token = this.consume('INTEGER');
                const node = { type: 'nonterminal', label: '<integer>', children: [] };
                
                let value = token.value;
                if (value.startsWith('-')) {
                    node.children.push({ type: 'terminal', label: '-' });
                    value = value.substring(1);
                }
                
                for (const digit of value) {
                    node.children.push({
                        type: 'nonterminal',
                        label: '<digit>',
                        children: [{ type: 'terminal', label: digit }]
                    });
                }
                
                return node;
            }
            
            parseString() {
                const token = this.consume('STRING');
                const node = { type: 'nonterminal', label: '<string>', children: [] };
                
                node.children.push({ type: 'terminal', label: '"' });
                
                const content = token.value.slice(1, -1);
                for (const char of content) {
                    node.children.push({
                        type: 'nonterminal',
                        label: '<nwnq>',
                        children: [{ type: 'terminal', label: char }]
                    });
                }
                
                node.children.push({ type: 'terminal', label: '"' });
                
                return node;
            }
            
            parseBoolean() {
                const token = this.consume('KEYWORD');
                if (token.value !== 'true' && token.value !== 'false') {
                    throw new Error(`Expected boolean, got '${token.value}'`);
                }
                return {
                    type: 'nonterminal',
                    label: '<boolean>',
                    children: [{ type: 'keyword', label: token.value }]
                };
            }
            
            parseList() {
                const node = { type: 'nonterminal', label: '<list>', children: [] };
                
                this.consume('SYMBOL', '[');
                node.children.push({ type: 'terminal', label: '[' });
                
                while (this.peek() && this.peek().value !== ']') {
                    node.children.push(this.parseExpr());
                }
                
                this.consume('SYMBOL', ']');
                node.children.push({ type: 'terminal', label: ']' });
                
                return node;
            }
            
            parseExpr() {
                const token = this.peek();
                if (!token) {
                    throw new Error('Unexpected end of input while parsing expression');
                }
                
                const node = { type: 'nonterminal', label: '<expr>', children: [] };
                
                if (token.type === 'INTEGER') {
                    node.children.push(this.parseInteger());
                } else if (token.type === 'KEYWORD' && (token.value === 'true' || token.value === 'false')) {
                    node.children.push(this.parseBoolean());
                } else if (token.type === 'STRING') {
                    node.children.push(this.parseString());
                } else if (token.value === '[') {
                    node.children.push(this.parseList());
                } else if (token.type === 'ID') {
                    node.children.push(this.parseId());
                } else if (token.value === '(') {
                    this.consume('SYMBOL', '(');
                    node.children.push({ type: 'terminal', label: '(' });
                    
                    const next = this.peek();
                    if (next && UNARY_OPS.includes(next.value)) {
                        
                        const op = this.consume('SYMBOL');
                        node.children.push({
                            type: 'nonterminal',
                            label: '<unary-op>',
                            children: [{ type: 'operator', label: op.value }]
                        });
                        node.children.push(this.parseExpr());
                    } else {
                        node.children.push(this.parseExpr());
                        
                        const opToken = this.peek();
                        if (!opToken || !BINARY_OPS.includes(opToken.value)) {
                            throw new Error(`Expected binary operator, got '${opToken ? opToken.value : 'end of input'}'`);
                        }
                        this.consume('SYMBOL');
                        node.children.push({
                            type: 'nonterminal',
                            label: '<binary-op>',
                            children: [{ type: 'operator', label: opToken.value }]
                        });
                        node.children.push(this.parseExpr());
                    }
                    
                    this.consume('SYMBOL', ')');
                    node.children.push({ type: 'terminal', label: ')' });
                } else {
                    throw new Error(`Invalid expression starting with '${token.value}'`);
                }
                
                return node;
            }
            
            
            parseAssign() {
                const node = { type: 'nonterminal', label: '<assign>', children: [] };
                node.children.push(this.parseId());
                this.consume('KEYWORD', 'gets');
                node.children.push({ type: 'keyword', label: 'gets' });
                node.children.push(this.parseExpr());
                return node;
            }
            
            
            parseVar() {
                const node = { type: 'nonterminal', label: '<var>', children: [] };
                this.consume('KEYWORD', 'var');
                node.children.push({ type: 'keyword', label: 'var' });
                node.children.push(this.parseAssign());
                return node;
            }
            
            
            parsePrint() {
                const node = { type: 'nonterminal', label: '<print>', children: [] };
                this.consume('KEYWORD', 'print');
                node.children.push({ type: 'keyword', label: 'print' });
                node.children.push(this.parseExpr());
                return node;
            }
            
           
            parseBody(endKeywords) {
                const node = { type: 'nonterminal', label: '<body>', children: [] };
                
                while (this.peek() && !endKeywords.includes(this.peek().value)) {
                    node.children.push(this.parseStatement());
                }
                
                return node;
            }
            
            
            parseIf() {
                const node = { type: 'nonterminal', label: '<if>', children: [] };
                
                this.consume('KEYWORD', 'if');
                node.children.push({ type: 'keyword', label: 'if' });
                node.children.push(this.parseExpr());
                this.consume('KEYWORD', 'then');
                node.children.push({ type: 'keyword', label: 'then' });
                node.children.push(this.parseBody(['elseif', 'else', 'endif']));
                
                while (this.peek() && this.peek().value === 'elseif') {
                    this.consume('KEYWORD', 'elseif');
                    node.children.push({ type: 'keyword', label: 'elseif' });
                    node.children.push(this.parseExpr());
                    this.consume('KEYWORD', 'then');
                    node.children.push({ type: 'keyword', label: 'then' });
                    node.children.push(this.parseBody(['elseif', 'else', 'endif']));
                }
                
                if (this.peek() && this.peek().value === 'else') {
                    this.consume('KEYWORD', 'else');
                    node.children.push({ type: 'keyword', label: 'else' });
                    node.children.push(this.parseBody(['endif']));
                }
                
                this.consume('KEYWORD', 'endif');
                node.children.push({ type: 'keyword', label: 'endif' });
                
                return node;
            }
            
            
            parseWhile() {
                const node = { type: 'nonterminal', label: '<while>', children: [] };
                
                this.consume('KEYWORD', 'while');
                node.children.push({ type: 'keyword', label: 'while' });
                node.children.push(this.parseExpr());
                this.consume('KEYWORD', 'do');
                node.children.push({ type: 'keyword', label: 'do' });
                node.children.push(this.parseBody(['endwhile']));
                this.consume('KEYWORD', 'endwhile');
                node.children.push({ type: 'keyword', label: 'endwhile' });
                
                return node;
            }
            
            parseRepeat() {
                const node = { type: 'nonterminal', label: '<repeat>', children: [] };
                
                this.consume('KEYWORD', 'repeat');
                node.children.push({ type: 'keyword', label: 'repeat' });
                node.children.push(this.parseExpr());
                this.consume('KEYWORD', 'times');
                node.children.push({ type: 'keyword', label: 'times' });
                node.children.push(this.parseBody(['endrepeat']));
                this.consume('KEYWORD', 'endrepeat');
                node.children.push({ type: 'keyword', label: 'endrepeat' });
                
                return node;
            }
            
            parseSub() {
                const node = { type: 'nonterminal', label: '<sub>', children: [] };
                
                this.consume('KEYWORD', 'sub');
                node.children.push({ type: 'keyword', label: 'sub' });
                node.children.push(this.parseId());
                this.consume('SYMBOL', '(');
                node.children.push({ type: 'terminal', label: '(' });
                
                while (this.peek() && this.peek().type === 'ID') {
                    node.children.push(this.parseId());
                }
                
                this.consume('SYMBOL', ')');
                node.children.push({ type: 'terminal', label: ')' });
                this.consume('KEYWORD', 'does');
                node.children.push({ type: 'keyword', label: 'does' });
                node.children.push(this.parseBody(['endsub']));
                this.consume('KEYWORD', 'endsub');
                node.children.push({ type: 'keyword', label: 'endsub' });
                
                return node;
            }
            
            parseCall() {
                const node = { type: 'nonterminal', label: '<call>', children: [] };
                
                this.consume('KEYWORD', 'call');
                node.children.push({ type: 'keyword', label: 'call' });
                node.children.push(this.parseId());
                this.consume('SYMBOL', '(');
                node.children.push({ type: 'terminal', label: '(' });
                
                while (this.peek() && this.peek().value !== ')') {
                    node.children.push(this.parseExpr());
                }
                
                this.consume('SYMBOL', ')');
                node.children.push({ type: 'terminal', label: ')' });
                
                return node;
            }
            
            parseExit() {
                this.consume('KEYWORD', 'exit');
                return {
                    type: 'nonterminal',
                    label: '<exit>',
                    children: [{ type: 'keyword', label: 'exit' }]
                };
            }
            
            
            parseStatement() {
                const token = this.peek();
                if (!token) {
                    throw new Error('Unexpected end of input while parsing statement');
                }
                
                const node = { type: 'nonterminal', label: '<statement>', children: [] };
                
                if (token.value === 'var') {
                    node.children.push(this.parseVar());
                } else if (token.value === 'print') {
                    node.children.push(this.parsePrint());
                } else if (token.value === 'if') {
                    node.children.push(this.parseIf());
                } else if (token.value === 'while') {
                    node.children.push(this.parseWhile());
                } else if (token.value === 'repeat') {
                    node.children.push(this.parseRepeat());
                } else if (token.value === 'sub') {
                    node.children.push(this.parseSub());
                } else if (token.value === 'call') {
                    node.children.push(this.parseCall());
                } else if (token.value === 'exit') {
                    node.children.push(this.parseExit());
                } else if (token.type === 'ID') {
                    node.children.push(this.parseAssign());
                } else {
                    throw new Error(`Invalid statement starting with '${token.value}'`);
                }
                
                return node;
            }
        }

        let useVisualTree = true;
        
        function renderTreeVisual(node) {
            if (!node.children || node.children.length === 0) {
                return `<span class="node ${node.type}">${escapeHtml(node.label)}</span>`;
            }
            
            let html = `<span class="node ${node.type}">${escapeHtml(node.label)}</span>`;
            html += '<ul>';
            for (const child of node.children) {
                html += `<li>${renderTreeVisual(child)}</li>`;
            }
            html += '</ul>';
            
            return html;
        }
        
        function renderTreeText(node, prefix = '', isLast = true) {
            const connector = isLast ? '└── ' : '├── ';
            const typeColor = {
                'nonterminal': 'color: #60a5fa;',
                'terminal': 'color: #34d399;',
                'keyword': 'color: #a78bfa;',
                'operator': 'color: #f87171;'
            };
            
            let result = prefix + connector + node.label + '\n';
            
            if (node.children) {
                const childPrefix = prefix + (isLast ? '    ' : '│   ');
                for (let i = 0; i < node.children.length; i++) {
                    result += renderTreeText(node.children[i], childPrefix, i === node.children.length - 1);
                }
            }
            
            return result;
        }
        
        function escapeHtml(text) {
            return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }
        
        function toggleView() {
            useVisualTree = !useVisualTree;
            const output = document.getElementById('treeOutput');
            if (output.dataset.tree) {
                const tree = JSON.parse(output.dataset.tree);
                displayTree(tree);
            }
        }
        
        function displayTree(tree) {
            const output = document.getElementById('treeOutput');
            output.dataset.tree = JSON.stringify(tree);
            
            if (useVisualTree) {
                output.innerHTML = `<div class="tree"><ul><li>${renderTreeVisual(tree)}</li></ul></div>`;
            } else {
                output.innerHTML = `<div class="text-tree">${escapeHtml(renderTreeText(tree, '', true))}</div>`;
            }
        }

        function parse() {
            const input = document.getElementById('inputCode').value;
            const parseType = document.getElementById('parseType').value;
            const status = document.getElementById('status');
            const errorDiv = document.getElementById('errorMessage');
            const output = document.getElementById('treeOutput');
            
            try {
                const tokens = tokenize(input);
                const parser = new Parser(tokens);
                
                let tree;
                switch (parseType) {
                    case 'id':
                        tree = parser.parseId();
                        break;
                    case 'expr':
                        tree = parser.parseExpr();
                        break;
                    case 'list':
                        tree = parser.parseList();
                        break;
                    case 'statement':
                        tree = parser.parseStatement();
                        break;
                    case 'assign':
                        tree = parser.parseAssign();
                        break;
                    case 'var':
                        tree = parser.parseVar();
                        break;
                    case 'print':
                        tree = parser.parsePrint();
                        break;
                    case 'exit':
                        tree = parser.parseExit();
                        break;
                    case 'if':
                        tree = parser.parseIf();
                        break;
                    case 'while':
                        tree = parser.parseWhile();
                        break;
                    case 'repeat':
                        tree = parser.parseRepeat();
                        break;
                    case 'sub':
                        tree = parser.parseSub();
                        break;
                    case 'call':
                        tree = parser.parseCall();
                        break;
                    default:
                        throw new Error('Unknown parse type');
                }
                
                if (!parser.isAtEnd()) {
                    const remaining = parser.tokens.slice(parser.pos).map(t => t.value).join(' ');
                    throw new Error(`Unexpected tokens after valid ${parseType}: '${remaining}'`);
                }
                
                status.textContent = 'Valid ✓';
                status.className = 'status valid';
                errorDiv.style.display = 'none';
                displayTree(tree);
                
            } catch (err) {
                status.textContent = 'Invalid ✗';
                status.className = 'status invalid';
                errorDiv.textContent = err.message;
                errorDiv.style.display = 'block';
                output.innerHTML = '';
                output.dataset.tree = '';
            }
        }
        
        const examples = {
            'id': [
                { label: 'X', value: 'X' },
                { label: 'x1y2', value: 'x1y2' },
                { label: 'abc', value: 'abc' },
                { label: '2b (invalid)', value: '2b' },
                { label: 'a_1 (invalid)', value: 'a_1' },
            ],
            'expr': [
                { label: '-4', value: '-4' },
                { label: '(-4) [invalid]', value: '(-4)' },
                { label: '(1 + -4)', value: '(1 + -4)' },
                { label: 'x', value: 'x' },
                { label: 'x*10 [invalid]', value: 'x*10' },
                { label: '(x * 10)', value: '(x * 10)' },
                { label: '(a & !b) [invalid]', value: '(a & !b)' },
                { label: '(a & (! b))', value: '(a & (! b))' },
                { label: '(3 > 2 > 1) [invalid]', value: '(3 > 2 > 1)' },
                { label: '((2 < 3) | true)', value: '((2 < 3) | true)' },
            ],
            'list': [
                { label: '[] (empty)', value: '[]' },
                { label: '["foo" 3]', value: '["foo" 3]' },
                { label: '[1 [2 3]]', value: '[1 [2 3]]' },
                { label: '[true "hi" 42]', value: '[true "hi" 42]' },
            ],
            'statement': [
                { label: 'x gets 0', value: 'x gets 0' },
                { label: 'var x gets 5', value: 'var x gets 5' },
                { label: 'print "hello"', value: 'print "hello"' },
                { label: 'exit', value: 'exit' },
            ],
            'assign': [
                { label: 'a gets 0 (minimal)', value: 'a gets 0' },
                { label: 'x gets (y + 1)', value: 'x gets (y + 1)' },
                { label: 'name gets "Bob"', value: 'name gets "Bob"' },
            ],
            'var': [
                { label: 'var x gets 0', value: 'var x gets 0' },
                { label: 'var count gets 100', value: 'var count gets 100' },
            ],
            'print': [
                { label: 'print 42', value: 'print 42' },
                { label: 'print "hello"', value: 'print "hello"' },
                { label: 'print (x + 1)', value: 'print (x + 1)' },
            ],
            'exit': [
                { label: 'exit', value: 'exit' },
            ],
            'if': [
                { label: 'if (x = y) then print "eq" endif', value: 'if (x = y) then print "eq" endif' },
                { label: 'if true then else endif', value: 'if true then else endif' },
                { label: 'if-elseif', value: 'if (grade > 90) then x gets "A" elseif (grade > 80) then x gets "B" endif' },
                { label: 'if-else', value: 'if (x > 0) then print "pos" else print "neg" endif' },
            ],
            'while': [
                { label: 'while 0 do endwhile (minimal)', value: 'while 0 do endwhile' },
                { label: 'while true do endwhile', value: 'while true do endwhile' },
                { label: 'with body', value: 'while (x > 0) do x gets (x + -1) endwhile' },
            ],
            'repeat': [
                { label: 'repeat 0 times endrepeat (minimal)', value: 'repeat 0 times endrepeat' },
                { label: 'repeat 5 times print "hi" endrepeat', value: 'repeat 5 times print "hi" endrepeat' },
                { label: 'repeat n times', value: 'repeat n times x gets (x + 1) endrepeat' },
            ],
            'sub': [
                { label: 'sub a ( ) does endsub (minimal)', value: 'sub a ( ) does endsub' },
                { label: 'with params', value: 'sub add ( x y ) does print (x + y) endsub' },
                { label: 'with body', value: 'sub greet ( name ) does print "Hello" print name endsub' },
            ],
            'call': [
                { label: 'call a ( ) (minimal)', value: 'call a ( )' },
                { label: 'call add ( 1 2 )', value: 'call add ( 1 2 )' },
                { label: 'call foo ( x (y + 1) )', value: 'call foo ( x (y + 1) )' },
            ],
        };
        
        function loadExample(value, type) {
            document.getElementById('inputCode').value = value;
            document.getElementById('parseType').value = type;
            parse();
        }
        
        function updateExamples() {
            const type = document.getElementById('parseType').value;
            const container = document.getElementById('exampleButtons');
            container.innerHTML = '';
            
            const typeExamples = examples[type] || [];
            for (const ex of typeExamples) {
                const btn = document.createElement('button');
                btn.className = 'example-btn';
                btn.textContent = ex.label;
                btn.onclick = () => loadExample(ex.value, type);
                container.appendChild(btn);
            }
        }
        
        document.getElementById('parseType').addEventListener('change', updateExamples);
        document.getElementById('inputCode').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') parse();
        });
        updateExamples();
        parse();
    </script>
</body>
</html>